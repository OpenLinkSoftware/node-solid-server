'use strict'

var request = require('request')
var url = require('url')
var uuid = require('uuid')
// var webid = require('webid')
var rdfstore = require('rdfstore')
var debug = require('./debug').authentication

exports.createWebIdUtils = function () {
  return new WebIdUtils()
}

/**
 * A class wrapping utility routines for WebID handling.
 * @constructor
 */
function WebIdUtils () {
}

WebIdUtils.prototype = {
  constructor: WebIdUtils,

  getInfoForWebID: function (webId) {
    var me = this
    var profileTmpGraphId = null

    return new Promise(function resolver (resolve, reject) {
      Promise.resolve(true).then(function (result) {
        // It's assumed the delegate's public key has already been checked by webid.verify()
        // Fetch the delegate's WebID profile
        //    This shouldn't fail if the delegate's WebID has already been verified.
        return me.getProfile(webId)
      }).then(function (profile) {
        // profile ::= { profile: <string>, contentType: <string> }

        return new Promise(function (resolve, reject) {
          rdfstore.create(function (err, store) {
            if (err) {
              reject(new Error('Could not create rdfstore'))
              return
            }

            profileTmpGraphId = 'urn:' + uuid.v4()
            var uriObj = url.parse(webId)
            uriObj.hash = uriObj.search = uriObj.query = null
            var base = url.format(uriObj)
            var options = {graph: profileTmpGraphId, documentIRI: base}

            switch (profile.contentType) {
              case 'text/turtle':
              case 'application/ld+json':
                store.load(profile.contentType, profile.profile, options, function (err, results) {
                  if (err) {
                    reject(new Error('Could not parse profile :' + profile.profile))
                    return
                  }
                  resolve(store)
                })
                break

              default:
                throw new Error("WebIdUtils#getInfoForWebID: Delegate's profile: Unexpected WebID profile content type")
            }
          })
        })
      }).then(function (store) {
        me.store = store

        return me.findInfoInWebIdProfile(
          me.store,
          profileTmpGraphId,
          webId)
      }).then(function (val) {
        resolve(val)
      }).catch(function (e) {
//      debug('WebIdUtils#getInfoForWebID: ', e)
        reject(e)
      })
    })
  },

  /**
   * Verifies a delegation claim.
   * Checks if the given delegate is authorized to authenticate or act on behalf of the given delegator.
   * @param {string} delegator - WebID of a 'principal' who allows a delegate to authenticate on their behalf
   * @param {string} - WebID of an agent that is assumed to be a delegate.
   * @param {object} - The delegate's certificate. This will already have been verified and used for
   *                   authenticating the delegate as part of setting up a WebID TLS connection.
   * @returns {promise}
   */
  verifyDelegation: function (delegator, delegate, delegateCertificate) {
    var me = this
    var delegateProfileTmpGraphId = null
    var delegatorProfileTmpGraphId = null
    var delegatorBase = null
    var stmtOnBehalfOfExists = false
    var stmtDelegatesExists = false
    var stmtHasIdentityDelegateExists = false
    var delegatorHasDelegatePublicKey = false

    debug('WebIdUtils#verifyDelegation')

    return new Promise(function resolver (resolve, reject) {
      Promise.resolve(true).then(function (result) {
        // It's assumed the delegate's public key has already been checked by webid.verify()
        // Fetch the delegate's WebID profile
        //    This shouldn't fail if the delegate's WebID has already been verified.
        return me.getProfile(delegate)
      }).then(function (profile) {
        // Load the delegate's profile into store
        // profile ::= { profile: <string>, contentType: <string> }
        return new Promise(function (resolve, reject) {
          rdfstore.create(function (err, store) {
            if (err) {
              reject(new Error('Could not create rdfstore'))
              return
            }

            store.registerCustomFunction('equalIgnoreCase', function (engine, args) {
              var v1 = engine.effectiveTypeValue(args[0]).toString()
              var v2 = engine.effectiveTypeValue(args[1]).toString()

              return engine.ebvBoolean(v1.toUpperCase() === v2.toUpperCase())
            })

            delegateProfileTmpGraphId = 'urn:' + uuid.v4()
            var uriObj = url.parse(delegate)
            uriObj.hash = uriObj.search = uriObj.query = null
            var delegateBase = url.format(uriObj)
            var options = {graph: delegateProfileTmpGraphId, documentIRI: delegateBase}

            switch (profile.contentType) {
              case 'text/turtle':
              case 'application/ld+json':
                store.load(profile.contentType, profile.profile, options, function (err, results) {
                  if (err) {
                    reject(new Error('Could not parse profile :' + profile.profile))
                  }
                  resolve(store)
                })
                break

              default:
                throw new Error("WebIdUtils#verifyDelegation: Delegate's profile: Unexpected WebID profile content type")
            }
          })
        })
      }).then(function (store) {
        me.store = store

        // Check if the statement "<{delegate}> oplcert:onBehalfOf <{delegator}>"  is exists
        return me.statementExists(
          me.store,
          delegateProfileTmpGraphId,
          delegate,
          'http://www.openlinksw.com/schemas/cert#onBehalfOf',
          delegator
        )
      }).then(function (result) {
        stmtOnBehalfOfExists = result
        debug(`WebIdUtils#verifyDelegation: Statement <${delegate}> oplcert:onBehalfOf <${delegator}> exists?:`, stmtOnBehalfOfExists)
        if (!stmtOnBehalfOfExists) {
          throw (new Error(`Relation <${delegate}> oplcert:onBehalfOf <${delegator}> not found.`))
        }
        return true
      }).then(function (result) {
        // Fetch the delegator's WebID profile
        return me.getProfile(delegator)
      }).then(function (profile) {
        // Load the delegator's profile into store
        // profile ::= { profile: <string>, contentType: <string> }
        return new Promise(function (resolve, reject) {
          delegatorProfileTmpGraphId = 'urn:' + uuid.v4()
          debug('WebIdUtils#verifyDelegation: temp graph id: ', delegatorProfileTmpGraphId)

          // base is used to expand null and relative URIs, <> and <#abc>
          var uriObj = url.parse(delegator)
          uriObj.hash = uriObj.search = uriObj.query = null
          delegatorBase = url.format(uriObj)
          var options = {graph: delegatorProfileTmpGraphId, documentIRI: delegatorBase}

          switch (profile.contentType) {
            case 'text/turtle':
            case 'application/ld+json':
              me.store.load(profile.contentType, profile.profile, options, function (err, results) {
                if (err) {
                  reject(new Error('Could not parse profile :' + profile.profile))
                }
                resolve(me.store)
              })
              break

            default:
              throw new Error("WebIdUtils#verifyDelegation: Delegator's profile: Unexpected WebID profile content type")
          }
        })
      }).then(function (store) {
        // Check if the statement "<{delegator}> oplcert:hasIdentityDelegate <{delegate}>" exists
        return me.statementExists(
          me.store,
          delegatorProfileTmpGraphId,
          delegator,
          'http://www.openlinksw.com/schemas/cert#hasIdentityDelegate',
          delegate
        )
      }).then(function (bHasIdentityDelegate) {
        stmtHasIdentityDelegateExists = bHasIdentityDelegate
        debug(`WebIdUtils#verifyDelegation: Statement <${delegator}> oplcert:hasIdentityDelegate <${delegate}> exists?:`, stmtHasIdentityDelegateExists)
        // Check if the statement "<{delegator}> acl:delegates <{delegate}>" exists
        return me.statementExists(
          me.store,
          delegatorProfileTmpGraphId,
          delegator,
          'http://www.w3.org/ns/auth/acl#delegates',
          delegate
        )
      }).then(function (bDelegates) {
        stmtDelegatesExists = bDelegates
        debug(`WebIdUtils#verifyDelegation: Statement <${delegator}> acl:delegates <${delegate}> exists: `, stmtDelegatesExists)
        // Check the delegator's profile contains the delegate's public key
        return me.findDelegatePublicKeyInDelegatorProfile(
          me.store,
          delegatorProfileTmpGraphId,
          delegate,
          delegateCertificate.modulus,
          delegateCertificate.exponent)
      }).then(function (delegatePublicKeyFromDelegatorProfile) {
        // logger.debug("WebIdUtils#verifyDelegation: delegate_public_key from delegator's profile: ", delegatePublicKeyFromDelegatorProfile);
        delegatorHasDelegatePublicKey = delegatePublicKeyFromDelegatorProfile !== null
        debug("WebIdUtils#verifyDelegation: Delegator's WebID profile contains the delegate's public key?: ", delegatorHasDelegatePublicKey)
        return true
      }).then(function (result) {
        if ((stmtHasIdentityDelegateExists || stmtDelegatesExists) && delegatorHasDelegatePublicKey) {
          resolve(true)
        } else {
          if (!delegatorHasDelegatePublicKey) {
            throw (new Error(`${delegatorBase} does not contain the public key of <${delegate}> .`))
          } else {
            var errMsg = `${delegatorBase} contains neither <${delegator}> acl:delegates <${delegate}> `
            errMsg += `nor <${delegator}> oplcert:hasIdentityDelegate <${delegate}>`
            throw (new Error(errMsg))
          }
        }
      }).catch(function (e) {
        debug('WebIdUtils#verifyDelegation: ', e)
        reject(e)
      })
    })
  },

  /**
   * Given a WebID, retrieves the WebID profile.
   * @returns {object} - An object with properties profile and contentType.
   */
  getProfile: function (webId) {
    return new Promise(function (resolve, reject) {
      var uri = url.parse(webId)
      var options = {
        url: uri,
        method: 'GET',
        headers: {
          'Accept': 'text/turtle, application/ld+json'
        }
      }

      request(options, function (err, res, body) {
        if (err) {
          return reject(new Error('Failed to fetch profile from ' + uri.href + ': ' + err))
        }

        if (res.statusCode !== 200) {
          return reject(new Error('Failed to retrieve WebID from ' + uri.href + ': HTTP status: ' + res.statusCode))
        }

        resolve({profile: body, contentType: res.headers['content-type']})
      })
    })
  },

  statementExists: function (store, graph, subject, predicate, object) {
    return new Promise(function (resolve, reject) {
      var qry = `ask where { graph <${graph}> { <${subject}> <${predicate}> <${object}> }}`
      try {
        store.execute(qry, function (err, results) {
          if (err) { reject(err) } else {
            resolve(results)
          }
        })
      } catch (e) {
        reject(e)
      }
    })
  }, // statementExists

  findDelegatePublicKeyInDelegatorProfile: function (store, graph, delegate, delegateModulus, delegateExponent) {
    return new Promise(function (resolve, reject) {
      /*
       * Matching exponents in a filter clause requires that we
       * ensure the exponent in the delegate's certificate and
       * delegator's profile use the same encoding.
       * e.g. One might be a decimal int, the other hex.
       * For now we don't bother.
       */
      var qry = `
        prefix cert: <http://www.w3.org/ns/auth/cert#> 
        select ?exponent ?modulus
        from <${graph}>
        where {
          <${delegate}> cert:key ?key .
          ?key cert:exponent ?exponent .
          ?key cert:modulus ?modulus .
          filter(custom:equalIgnoreCase(?modulus, "${delegateModulus}"))
        } limit 1
        `

      try {
        store.execute(qry, function (err, results) {
          if (err) {
            reject(err)
          } else {
            var publicKey = null
            if (results.length === 1) {
              publicKey = {}
              publicKey.exponent = { datatype: results[0].exponent.type, value: results[0].exponent.value }
              publicKey.modulus = { datatype: results[0].modulus.type, value: results[0].modulus.value }
            }
            resolve(publicKey)
          }
        })
      } catch (e) {
        reject(e)
      }
    })
  },

  findInfoInWebIdProfile: function (store, graph, webId) {
    return new Promise(function (resolve, reject) {
      var qry = `
        PREFIX foaf:<http://xmlns.com/foaf/0.1/> 
        PREFIX schema: <http://schema.org/> 
        PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> 
        PREFIX skos: <http://www.w3.org/2004/02/skos/core#> 
        prefix cert: <http://www.w3.org/ns/auth/cert#> 
        prefix pim: <http://www.w3.org/ns/pim/space#> 

        select *
        from <${graph}>
        where {
         {{<${webId}> schema:name ?schema_name} UNION 
         {<${webId}> foaf:name ?foaf_name} UNION 
         {<${webId}> rdfs:label ?rdfs_name} UNION 
         {<${webId}> skos:prefLabel ?skos_prefLabel} UNION 
         {<${webId}> skos:altLabel ?skos_altLabel} 
         }
         OPTIONAL {<${webId}> pim:storage ?pim_store }.
        }`

      try {
        store.execute(qry, function (err, results) {
          if (err) {
            reject(err)
          } else {
            var pimStore = null
            var name = null
            if (results.length >= 1) {
              var r = results[0]
              if (r.schema_name) {
                name = r.schema_name.value
              } else if (r.foaf_name) {
                name = r.foaf_name.value
              } else if (r.rdfs_name) {
                name = r.rdfs_name.value
              } else if (r.skos_prefLabel) {
                name = r.skos_prefLabel.value
              } else if (r.skos_altLabel) {
                name = r.skos_altLabel.value
              }
              if (r.pim_store) {
                pimStore = r.pim_store.value
              }
            }
            resolve({name, pimStore})
          }
        })
      } catch (e) {
        reject(e)
      }
    })
  }

}
